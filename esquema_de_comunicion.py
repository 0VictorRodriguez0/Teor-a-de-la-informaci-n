# -*- coding: utf-8 -*-
"""Esquema de comunicion.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1AOsUFl83ufnTgiWYl9B6Jw23n4J7HHsG
"""

# pip install bitstring

from bitstring import BitArray
import random
import time
import math
import random

#Entropia de shannon
def EntropiaConocida(probabilidad):
  E = -(math.log(probabilidad, 2))
  return E

def EntropiaAleatoria(probabilidades):
  k = len(probabilidades)
  suma = 0
  for i in range(0,k):
    # print(i)
    if probabilidades[i] > 0:
      Ek = probabilidades[i] * math.log(probabilidades[i], 2)
      suma = suma + Ek
  return -suma

#Fuente de información
#pide como entrada un mensaje
def Finformacin():

    nombre = str(input("Escribe tu mensaje "))
    return nombre

#pasa del string a una lista de caracteres
def separar(mensaje):
  lista = []
  for i in mensaje:
    lista.append(i)
  return lista

#convierte el mensaje a binario
def transmite(mensaje):
    # Convertir el mensaje en una secuencia de bits
    bitsM = BitArray(bytes=mensaje.encode('utf-8'))
    return bitsM.bin

#enpaqueta los datos con INIT al inicio y FIN al final de la cadena
def enpaquetar(cadena):
  pack = ["INI"]
  for i in range(len(cadena)):
    pack.append(cadena[i])
  pack.append("FIN")
  return pack

#Reproduce posible ruido sobre las cadenas de bits
#entra: palabra de 8 bits
#sale: palabra con 8 bits con posible cambio en alguno de los bits
def ruido(LetraBytes):
  causa = False
  letra = LetraBytes
  aleatorio1 = random.randint(1, 10)
  # aleatorio2 = random.randint(1, 5)
  if aleatorio1 < 3:
    causa = True
    aleatorioBytes = random.randint(0,7)
    # print(aleatorioBytes,letra[aleatorioBytes])
    if letra[aleatorioBytes] == "0":
      # print("cambio a 1",aleatorioBytes)
      letra = letra[:aleatorioBytes] + '1' + letra[aleatorioBytes + 1:]
    else:
      # print("cambio a 0",aleatorioBytes)
      letra = letra[:aleatorioBytes] + '0' + letra[aleatorioBytes + 1:]


  return letra,causa

#Crea ruido en el mensaje y envia los mensajes cada  0.08 segundos.
def canal(letraB):
  letraR,CausaR = ruido(letraB)
  # print(CausaR)
  # print(letraR)
  velocidad_mbps = 100
  tiempo_teórico = 8 / velocidad_mbps  # Convertimos megabits a bits
  time.sleep(tiempo_teórico)
  verdad = random.randint(0, 1)
  if(verdad):
    print("transferiendo")
  return letraR,CausaR

#Decodifica el mensaje de binario a carácter
def decodifica(letraB):
  #  bits a decimal
  decimal = int(letraB, 2)
  # decimal a carácter
  caracter = chr(decimal)
  return caracter

#Recibe el mensaje enpaquetado y lo decodifica de binario a caracter
def receptor(listaB):
  MensajeFin = []
  listaRuido = []
  # print(len(listaB)-2)
  if((listaB[0] == 'INI') & (listaB[len(listaB)-1] == 'FIN')):
    for i in range(1,len(listaB)-1):
      # print(listaB[i])
      BinR,CausaC = canal(listaB[i])
      #guardar probabilidades
      if(CausaC):
        listaRuido.append(1/(len(listaB)-2))
      else:
        listaRuido.append(0)

      Letra = decodifica(BinR)
      MensajeFin.append(Letra)
    print("lista de probabilidades: ",listaRuido)
    print("Entropia de shannon: ",EntropiaAleatoria(listaRuido))
  else:
    print("EL mensaje no se encuentra enpaquetado")

  return MensajeFin

#recibe la lista de caracteres y las pasa a un string
def Destino(Mensaje):
  MensajeDestino = ''.join(Mensaje)
  print("Mensaje Recibido... :",MensajeDestino)

#Escribir mensaje
mensaje = Finformacin()
print("Mensaje enviado.... :",mensaje)

#pasar el mensaje a una lista
ListMensaje = separar(mensaje)

#convertir cada uno de los caracteres a binario
BinariList = [transmite(caracter) for caracter in ListMensaje]

#enpaquetar los datos
packBList = enpaquetar(BinariList)
#recibir y decodificar los datos
entrega = receptor(packBList)

#recbir los datos finales y convertir de lista a string
Destino(entrega)